# imports are program code that is needed to run your program
from flask import Flask, render_template, request, redirect # to run Flask
import datetime
import time
import subprocess
import os # needed to check if events file exists
import RPi.GPIO as GPIO
import threading

'''
Source file: flask_server.py
Start: sudo flask_server.py
@author: Patrick Brouwer
@author: Mark
@author: Clemens
'''

#I AM THE MASTER OF THE PI'S!!!
masterPi = False



#exitFlag for animation tread
exitFlag = 0
quitAll = 0
queueLock = threading.Lock()
threads = []
LeadingTreads = []

def readfile( file_name ):
	response = "OK"
	try:
		# check if event file already exists; if not, create it
		if not os.path.exists(file_name):
			response = "File does not exist"
		else:
			# open the button events event file for reading
			event_file = open(file_name, "r")
			# read all lines from the file into a Python list called 'lines'
			lines = [line.rstrip('\n') for line in event_file]	# strip new line character from each line in file	
			# close event file
			event_file.close()
	except:
		response = "There was an error reading the events "
	if(response == "OK"):
	    	return lines[0]
	else:
		return response

lightOn = 1;
# light on function 
def light(state="TROLL"): 
	# to use Raspberry Pi board pin numbers 
	GPIO.setmode(GPIO.BCM) 
	# set up GPIO output channel 
	GPIO.setup(4, GPIO.OUT)

	global lightOn
	lightPin = 4  
	if(state=="ON") or (lightOn == 0):
		print "light on"
        	GPIO.output(lightPin,True)
		lightOn = 1
	else:
		print "light off"
        	GPIO.output(lightPin,GPIO.LOW) 
		lightOn = 0
        return 1

#turn light off
light()
GPIO.cleanup() #clean up my stuff



def rotateMotor(steps=0, direction="UP" ):
	global exitFlag, quitAll
	# Use BCM GPIO references
	# instead of physical pin numbers
	GPIO.setmode(GPIO.BCM)

	buttonPin = 25
	prev_state = 1
	GPIO.setup(buttonPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
	event = 1
	 
	# Define GPIO signals to use
	# Pins 18,22,24,26
	# GPIO24,GPIO25,GPIO8,GPIO7
	StepPins = [17,18,27,22]
	 
	# Set all pins as output
	for pin in StepPins:
	  GPIO.setup(pin,GPIO.OUT)
	  GPIO.output(pin, False)
	 
	# Define some settings
	StepCounter = 0
	WaitTime = 0.0025
	 
	# Define simple sequence
	
	#up
	StepCount1 = 4
	Seq1 = []
	Seq1 = range(0, StepCount1)
	
	Seq1[0] = [0,0,0,1]
	Seq1[1] = [0,0,1,0]
	Seq1[2] = [0,1,0,0]
	Seq1[3] = [1,0,0,0]
	
	#down
	StepCount2 = 4
	Seq2 = []
	Seq2 = range(0, StepCount2)	

	Seq2[0] = [1,0,0,0]
	Seq2[1] = [0,1,0,0]
	Seq2[2] = [0,0,1,0]
	Seq2[3] = [0,0,0,1]
	 
	# Choose a sequence to use
	if(direction == "UP"):
		Seq = Seq1
		StepCount = StepCount1
	else:
		Seq = Seq2
		StepCount = StepCount2
	
	if(steps == 0): 
		# infinity loop
		while exitFlag != 0:
		 curr_state = GPIO.input(buttonPin)
		 if (curr_state != prev_state):
			break

		 for pin in range(0, 4):		
			xpin = StepPins[pin]
			if Seq[StepCounter][pin]!=0:
				#print " Step %i Enable %i" %(StepCounter,xpin)
				GPIO.output(xpin, True)
			else:
				GPIO.output(xpin, False)
		 
		 StepCounter += 1
		 
		 # If we reach the end of the sequence
		 # start again
		 if (StepCounter==StepCount):
		   StepCounter = 0
		 if (StepCounter<0):
		   StepCounter = StepCount
		 
		 # Wait before moving on
		 time.sleep(WaitTime)
	else:
		# for loop
		for x in range(0, steps):
		  if(exitFlag != 0 and quitAll != 1):
			break
		  DownfromHomeIgnore = 0
		  if(direction != "UP"):
			DownfromHomeIgnore = 30
		  curr_state = GPIO.input(buttonPin)
		  if (x > DownfromHomeIgnore) and (curr_state != prev_state):
			break
		 
		  for pin in range(0, 4):
			xpin = StepPins[pin]
			if Seq[StepCounter][pin]!=0:
				#print " Step %i Enable %i" %(StepCounter,xpin)
				GPIO.output(xpin, True)
			else:
				GPIO.output(xpin, False)
		 
		  StepCounter += 1
		 
		  # If we reach the end of the sequence
		  # start again
		  if (StepCounter==StepCount):
		    StepCounter = 0
		  if (StepCounter<0):
		    StepCounter = StepCount
		 
		  # Wait before moving on
		  time.sleep(WaitTime)
		

	GPIO.cleanup()
	return 1

class trolTreads (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
	os.system('sudo shutdown -rF now')

class StopTreads (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
	os.system('sudo shutdown -h now')

# create a Flask objec called app
app = Flask(__name__)

# URL: http://IPADRESS:5000/
@app.route('/')
@app.route("/index.htm")
def index():
    	templateData = {
		'title' : "Raspberry aansturing Home",
		'xpos' : readfile('/boot/x.txt'),
		'ypos' : readfile('/boot/y.txt')
	}
	# return the main.html template to the web browser and pass into it the variables in the templateData dictionary
	return render_template('index.html', **templateData)

@app.route('/home.htm')
def home():
	rotateMotor(0)
	return 'Im Ready!'

@app.route('/lightcontrol.htm')
def lightControl():
	light()
	return redirect("/", code=302)

@app.route('/up.htm', methods=['GET'])
def up():
	if (request.method == 'GET'):
		steps = request.args.get("steps")
		if steps is None:
			rotateMotor(1,"UP")		
		else:		
			rotateMotor(int(steps),"UP")
	return 'Im ready'

@app.route('/down.htm', methods=['GET'])
def down():
	if (request.method == 'GET'):
		steps = request.args.get("steps")
		if steps is None:
			rotateMotor(1,"DOWN")		
		else:		
			rotateMotor(int(steps),"DOWN")
    	return 'Im Ready!'

@app.route('/xpos.htm')
def xpos():
	file_name = "/boot/x.txt"
    	return readfile(file_name)

@app.route('/ypos.htm')
def ypos():
    	file_name = "/boot/y.txt"
    	return readfile(file_name)

class autoAnimate (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
	global exitFlag, quitAll
	global rotateMotor
	rotateMotor(steps=6000, direction="DOWN")
        while exitFlag != 1 and quitAll != 1:
		rotateMotor(steps=5000, direction="UP")
		rotateMotor(steps=5000, direction="DOWN")


@app.route('/auto_on.htm')
def auto_on(feedback=True):
	#set light on
	light("ON")
	# Create new threads
	global exitFlag,threads
	exitFlag = 0
	#start tread
	thread = autoAnimate()
	thread.start()
	threads.append(thread)
	time.sleep(2)
	#set light off
	light()
	if(feedback==True):
    		return render_template('auto_on.html',)
	else:
		return 1


@app.route('/auto_off.htm')
def auto_off():
	#set light on for shutdown
	light("ON")
	#give tread exit flag	
	global exitFlag,threads
	exitFlag = 1
	# Wait for all threads to complete
	for t in threads:
	    t.join()
	time.sleep(1)
	exitFlag = 0
    	return 'Im Ready!'

@app.route('/shutdown.htm')
def shutdown():
	os.system('sudo shutdown -h now')
	thread = StopTreads()
	thread.start()
	
    	return 'Shutdown the raspberry. bye bye!'

@app.route('/reboot.htm')
def reboot():
	thread = trolTreads()
	thread.start()
	return 'reboot raspberry now. See you soon!'
	

@app.route('/animatie1.htm')
def animatie1():
	rotateMotor(steps=2000, direction="DOWN")
	for x in range(0, 10):
		rotateMotor(steps=1000, direction="UP")
		rotateMotor(steps=1000, direction="DOWN")	
	
	rotateMotor(steps=0, direction="UP")
	return 'Im ready!'

@app.route('/animatie2.htm')
def animatie2():
        rotateMotor(steps=2500, direction="DOWN")
        for x in range(0, 10):
                rotateMotor(steps=1000, direction="UP")
                rotateMotor(steps=1000, direction="DOWN")

        rotateMotor(steps=0, direction="UP")
        return 'Im ready!'

@app.route('/animatie3.htm')
def animatie3():
        rotateMotor(steps=3000, direction="DOWN")
        for x in range(0, 10):
                rotateMotor(steps=1000, direction="UP")
                rotateMotor(steps=1000, direction="DOWN")

        rotateMotor(steps=0, direction="UP")
        return 'Im ready!' 

@app.route('/kill.htm')
def kill():
	GPIO.cleanup()
        return 'Im ready!'

class checkLight (threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
	global exitFlag, threads, autoAnimate,quitAll
	# global variables
	sensorPin = 24  # this will be an input pin to which the button is attached
					# in this case pin GPIO23 (which is pin number 16)
	prev_state = 0
	start_state = 0
  # set start state to 1 (button released)

	print "start job"
	while quitAll <= 0:
		# we're using the BCM pin layout of the Raspberry PI
		GPIO.setmode(GPIO.BCM)

		# set pin GPIO23 to be an input pin; this pin will read the button state
		# activate pull down for pin GPIO23
		GPIO.setup(sensorPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
		curr_state = GPIO.input(sensorPin)

		# if state changed, take some actions
		if (curr_state != prev_state):  
			if (curr_state == 0): 
				print "JOB Light ON"
				if(start_state == 1):
					print "JOB AUTO OFF"
					auto_off()	
					start_state = 0
				else:	
					time.sleep(1)
					auto_on(False)
					print "JOB AUTO ON"
					start_state = 1

			prev_state = curr_state  

		time.sleep(0.02)

if(masterPi == False):
	threadLight = checkLight()
	threadLight.start()
	LeadingTreads.append(threadLight)


# if the script was run directly from the command line
if __name__ == "__main__":
	# have the local host server listen on port 80, and report any errors
	app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False) # if permission denied; change port
